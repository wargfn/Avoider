package{		/*	...	author:wargfn@wargfndev.blogspot.com	Main Game Loop		Game Based on Frozen Haddock and Michael James Williams	*/		import flash.display.MovieClip;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.text.TextField;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import flash.events.Event;	import Classes.Enemy;	import Classes.Avatar;	import Classes.PixelPerfectCollisionDetection;		public class AvoiderGame extends MovieClip	{				public var army:Array;		public var avatar:Avatar;		public var gameTimer:Timer;		public var playScreen:AvoiderGame;		public var useMouseControl:Boolean;		public var downKeyIsBeingPressed:Boolean;		public var upKeyIsBeingPressed:Boolean;		public var leftKeyIsBeingPressed:Boolean;		public var rightKeyIsBeingPressed:Boolean;						public function AvoiderGame()		{			/* Originally used to display the			background, but it seems that it was unneeded			playScreen = new PlayScreen();			playScreen.x = 0;			playScreen.y = 0;			addChild(playScreen); */			//setting up to use mouse			useMouseControl = false;			downKeyIsBeingPressed = false;			upKeyIsBeingPressed = false;			leftKeyIsBeingPressed = false;			rightKeyIsBeingPressed = false;						army = new Array();			//pushing one starting enemy just to be sure			var newEnemy = new Enemy(100, -15);			army.push(newEnemy);			addChild(newEnemy);									avatar = new Avatar();			addChild(avatar);						if(useMouseControl == true)			{				avatar.x = mouseX;				avatar.y = mouseY;			}			else			{				avatar.x = 200;				avatar.y = 250;			}						gameTimer = new Timer( 25 );			gameTimer.addEventListener(TimerEvent.TIMER, onTick);			gameTimer.start();						addEventListener( Event.ADDED_TO_STAGE, onAddToStage );					}				public function getFinalScore():Number		{			return gameScore.currentValue;		}				public function getFinalClockTime():Number		{			return gameClock.currentValue;		}				public function onTick(timerEvent:TimerEvent):void		{						gameClock.addToValue(25);						if ( Math.random() < 0.1)			{								var randomX:Number = Math.random() * 400;				var newEnemy:Enemy = new Enemy(randomX, -15);				army.push(newEnemy);				addChild(newEnemy);				gameScore.addToValue(10);				//trace(randomX.toString());						}						var avatarHasBeenHit:Boolean = false;						for each (var enemy:Enemy in army)			{								enemy.moveABit();							//Old BOX based collions				//if(avatar.hitTestObject(enemy))				if ( PixelPerfectCollisionDetection.isColliding( avatar, enemy, this, true ) )				{									gameTimer.stop();					//dispatchEvent( new AvatarEvent (AvatarEvent.DEAD) );					avatarHasBeenHit = true;								}							}			//okay wife wants scoring to happen when smiles leave the screen!!			// remember that its either side <0 400> and bottom >300			//so that means rolling through each element in the array one at a time			for( var i:int = 0; i < army.length; i++)			{				var senemy = army[i];				/*if (enemy.scoreHit(enemy.x, enemy.y) == true)				{					gameScore.addToValue(10);				}*/				//this is tracing correctly, just cant seem to remove the element				if(senemy.x < (0 - senemy.width) || senemy.x > (400 + senemy.width) || senemy.y > (300 + senemy.height))				{					var j:int = army.indexOf(senemy);					//splicing causes some onscreen to stop as well					//army.splice(j);					//removeChild(army[i]);					trace("Enemy out of bounds " + j.toString());				}			}						if(avatarHasBeenHit == true)			{								dispatchEvent(new AvatarEvent(AvatarEvent.DEAD));							}						if(useMouseControl == true)			{				avatar.x = mouseX;				avatar.y = mouseY;			}			else			{				//right some controls initially just four directions				//now in eight directions test combo keys first!!!				if (downKeyIsBeingPressed && leftKeyIsBeingPressed)				{					avatar.moveABit( -1, 1, 2);				}				else if (downKeyIsBeingPressed && rightKeyIsBeingPressed)				{					avatar.moveABit(1, 1, 2);				}				else if (upKeyIsBeingPressed && leftKeyIsBeingPressed)				{					avatar.moveABit( -1, -1, 2);				}				else if (upKeyIsBeingPressed && rightKeyIsBeingPressed)				{					avatar.moveABit(1, -1, 2);				}				//old four direction movement				else if ( downKeyIsBeingPressed )				{					avatar.moveABit( 0, 1, 3 );				}				else if ( upKeyIsBeingPressed )				{						avatar.moveABit( 0, -1, 3 );				}				else if ( leftKeyIsBeingPressed )				{					avatar.moveABit( -1, 0, 3 );				}				else if ( rightKeyIsBeingPressed )				{					avatar.moveABit( 1, 0, 3 );				}							}						//Keep Avatar on the Screen			if ( avatar.x < ( avatar.width / 2 ) )			{				avatar.x = avatar.width / 2;			}			if ( avatar.y < ( avatar.height / 2))			{				avatar.y = avatar.height / 2;			}			if ( avatar.x > 400 - avatar.width / 2 )			{				avatar.x = 400 - avatar.width / 2;			}			if ( avatar.y > 300 - avatar.height / 2)			{				avatar.y = 300 - avatar.height / 2;			}		}				public function onKeyPress(keyboardEvent:KeyboardEvent):void		{						if ( keyboardEvent.keyCode == Keyboard.DOWN )			{				downKeyIsBeingPressed = true;			}			else if ( keyboardEvent.keyCode == Keyboard.UP )			{				upKeyIsBeingPressed = true;			}			else if ( keyboardEvent.keyCode == Keyboard.LEFT )			{				leftKeyIsBeingPressed = true;			}			else if ( keyboardEvent.keyCode == Keyboard.RIGHT )			{				rightKeyIsBeingPressed = true;			}		}				public function onKeyRelease(keyboardEvent:KeyboardEvent):void		{						if ( keyboardEvent.keyCode == Keyboard.DOWN )			{				downKeyIsBeingPressed = false;			}			else if ( keyboardEvent.keyCode == Keyboard.UP )			{				upKeyIsBeingPressed = false;			}			else if ( keyboardEvent.keyCode == Keyboard.LEFT )			{				leftKeyIsBeingPressed = false;			}			else if ( keyboardEvent.keyCode == Keyboard.RIGHT )			{				rightKeyIsBeingPressed = false;			}					}				public function onAddToStage( event:Event ):void		{			stage.addEventListener( KeyboardEvent.KEY_DOWN, onKeyPress );			stage.addEventListener( KeyboardEvent.KEY_UP, onKeyRelease );		}			}	}